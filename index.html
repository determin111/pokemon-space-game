<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å®å¯æ¢¦å¤ªç©ºå¯¹æˆ˜</title>
    <style>
        /* ä¹‹å‰å®šä¹‰çš„cssæ ·å¼ */
        html,
        body {
            margin: 0;
            padding: 0;
            position: fixed;
            overflow: hidden;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000;
            font-family: Arial, sans-serif;
        }

        #gameCanvas {
            border: 1px solid #333;
            max-width: 100%;
            max-height: 100%;
            display: none;
        }

        #intro-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            /* Or your desired intro background */
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            text-align: center;
            z-index: 1000;
            /* Ensure intro is on top */
            cursor: pointer;
            /* Add cursor hint */
        }

        /* Style for the intro video */
        #intro-video {
            max-width: 80%;
            max-height: 60%;
            margin-bottom: 20px;
            /* Add some space below the video */
        }

        .game-over {
            position: absolute;
            color: white;
            text-align: center;
            display: none;
        }

        .game-over h1 {
            color: red;
            font-size: 30px;
        }

        .game-over p {
            font-size: 20px;
            margin: 10px 0;
        }

        #joystick {
            position: absolute;
            bottom: 30px;
            /* è°ƒæ•´æ‘‡æ†çš„ä½ç½® */
            left: 30px;
            /* è°ƒæ•´æ‘‡æ†çš„ä½ç½® */
            width: 100px;
            height: 100px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            /* ä½¿å®ƒå˜æˆåœ†å½¢ */
            display: flex;
            justify-content: center;
            /* æ°´å¹³å±…ä¸­ */
            align-items: center;
            /* å‚ç›´å±…ä¸­ */
            display: none;
            /* Hide during intro */
        }

        #joystick-handle {
            width: 50px;
            height: 50px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            /* ä½¿æ‰‹æŸ„å˜æˆåœ†å½¢ */
            position: absolute;
        }

        #fire-button {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 80px;
            height: 80px;
            background-color: rgba(255, 0, 0, 0.7);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            user-select: none;
            /* ç¦æ­¢æ–‡æœ¬é€‰æ‹© */
            display: none;
            /* Hide during intro */
        }

        #pause-button {
            position: absolute;
            top: 30px;
            right: 30px;
            width: 60px;
            height: 40px;
            background-color: rgba(0, 0, 255, 0.7);
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 18px;
            user-select: none;
            /* ç¦æ­¢æ–‡æœ¬é€‰æ‹© */
            display: none;
            /* Hide during intro */
        }

        /* æ’è¡Œæ¦œæ ·å¼ */
        #leaderboard {
            position: absolute;
            top: 80px;
            /* è°ƒæ•´ä½ç½®é¿å…ä¸æš‚åœæŒ‰é’®é‡å  */
            left: 30px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
            /* åˆå§‹éšè— */
            z-index: 1000;
            /* ç¡®ä¿æ˜¾ç¤ºåœ¨æœ€ä¸Šå±‚ */
            max-height: 200px;
            /* é™åˆ¶æœ€å¤§é«˜åº¦ */
            overflow-y: auto;
            /* è¶…å‡ºé«˜åº¦æ—¶æ˜¾ç¤ºæ»šåŠ¨æ¡ */
        }

        #leaderboard h2 {
            margin-top: 0;
            font-size: 20px;
        }

        #leaderboard ol {
            padding-left: 20px;
        }

        #leaderboard li {
            font-size: 16px;
            margin-bottom: 5px;
        }

        /* æ˜¾ç¤ºæ’è¡Œæ¦œæŒ‰é’® */
        #show-leaderboard-button {
            /* ä¿®æ”¹äº†ID */
            position: absolute;
            top: 30px;
            left: 30px;
            /* è°ƒæ•´åˆ°å·¦è¾¹ */
            width: 100px;
            /* å¢åŠ å®½åº¦ä»¥ä¾¿å®¹çº³æ–‡æœ¬ */
            height: 40px;
            background-color: rgba(0, 255, 0, 0.7);
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: black;
            font-size: 14px;
            user-select: none;
            cursor: pointer;
            display: none;
            /* Hide during intro */
        }

        /* Multiplayer Panel Styles */
        #multiplayer-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            display: none;
            z-index: 2000;
            width: 80%;
            max-width: 400px;
            text-align: center;
        }

        #multiplayer-panel h2 {
            margin-top: 0;
            color: #00FF00;
        }

        #multiplayer-panel input,
        #multiplayer-panel button {
            display: block;
            width: 100%;
            padding: 10px;
            margin: 10px auto;
            border-radius: 5px;
            border: none;
        }

        #multiplayer-panel button {
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        #multiplayer-panel button:hover {
            background-color: #367c39;
        }

        #player-list {
            margin-top: 20px;
            padding: 10px;
            border-top: 1px solid #555;
        }

        #player-list h3 {
            margin-bottom: 10px;
            color: #DDD;
        }

        #player-list div {
            padding: 8px;
            margin: 5px 0;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            text-align: left;
        }

        #show-multiplayer-button {
            position: absolute;
            top: 30px;
            left: 140px;
            width: 100px;
            height: 40px;
            background-color: rgba(255, 165, 0, 0.7);
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: black;
            font-size: 14px;
            user-select: none;
            cursor: pointer;
            display: none;
            /* Hide during intro */
        }

        /* Styles for player names in multiplayer */
        .player-name {
            position: absolute;
            color: white;
            font-size: 12px;
            text-align: center;
            pointer-events: none;
        }

        /* Room info display */
        .room-info {
            position: absolute;
            top: 10px;
            right: 100px;
            background-color: rgba(0, 0, 0, 0.7);
            color: yellow;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
        }
    </style>
</head>

<body>
    <div id="intro-screen">
        <video id="intro-video" src="videos/pokemon_intro.mp4" preload="metadata"></video>
        <h1>å®å¯æ¢¦å¤ªç©ºå¯¹æˆ˜</h1>
        <p>ç‚¹å‡»æˆ–è§¦æ‘¸å±å¹•å¼€å§‹</p>
    </div>
    <canvas id="gameCanvas" width="400" height="600"></canvas>
    <div class="game-over" id="gameOverScreen">
        <h1>æ¸¸æˆç»“æŸ</h1>
        <p id="finalScore">æœ€ç»ˆåˆ†æ•°: 0</p>
        <p>æŒ‰ä»»æ„é”®æˆ–ç‚¹å‡»å±å¹•é‡æ–°å¼€å§‹</p>
    </div>

    <!-- æ‘‡æ† -->
    <div id="joystick">
        <div id="joystick-handle"></div>
    </div>
    <!-- å°„å‡»æŒ‰é’® -->
    <div id="fire-button">ğŸ”¥</div>
    <!-- æš‚åœæŒ‰é’® -->
    <div id="pause-button">â¸ï¸</div>

    <!-- æ’è¡Œæ¦œ -->
    <div id="leaderboard">
        <h2>æ’è¡Œæ¦œ</h2>
        <ol id="leaderboard-list"></ol>
    </div>

    <!-- æ˜¾ç¤ºæ’è¡Œæ¦œæŒ‰é’® -->
    <div id="show-leaderboard-button">æŸ¥çœ‹æ’è¡Œæ¦œ</div>

    <!-- Multiplayer Button -->
    <div id="show-multiplayer-button">å¤šäººè”æœº</div>

    <!-- Multiplayer Panel -->
    <div id="multiplayer-panel">
        <h2>å¤šäººè”æœºæ¨¡å¼</h2>
        <input type="text" id="player-name" placeholder="è¾“å…¥ä½ çš„æ¸¸æˆåç§°">
        <button id="create-room-btn">åˆ›å»ºæˆ¿é—´</button>
        <button id="join-room-btn">åŠ å…¥æˆ¿é—´</button>
        <input type="text" id="room-id" placeholder="è¾“å…¥æˆ¿é—´ID" style="display:none;">
        <button id="start-game-btn" style="display:none;">å¼€å§‹æ¸¸æˆ</button>
        <div id="player-list">
            <h3>åœ¨çº¿ç©å®¶</h3>
        </div>
        <button id="close-panel-btn">å…³é—­</button>
    </div>

    <script>
        console.log("JavaScript file loaded and running");
        class PokemonSpaceGame {
            constructor() {
                // Canvas and Game Over elements
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.gameOverScreen = document.getElementById('gameOverScreen');
                this.finalScoreText = document.getElementById('finalScore');
                this.introScreen = document.getElementById('intro-screen');
                this.introVideo = document.getElementById('intro-video'); // Get the video element

                // Leaderboard elements
                this.leaderboardElement = document.getElementById('leaderboard');
                this.leaderboardList = document.getElementById('leaderboard-list');
                this.showLeaderboardButton = document.getElementById('show-leaderboard-button');

                // Multiplayer elements
                this.multiplayerPanel = document.getElementById('multiplayer-panel');
                this.showMultiplayerButton = document.getElementById('show-multiplayer-button');
                this.playerNameInput = document.getElementById('player-name');
                this.createRoomBtn = document.getElementById('create-room-btn');
                this.joinRoomBtn = document.getElementById('join-room-btn');
                this.roomIdInput = document.getElementById('room-id');
                this.startGameBtn = document.getElementById('start-game-btn');
                this.playerList = document.getElementById('player-list');
                this.closePanelBtn = document.getElementById('close-panel-btn');

                // Game state
                this.gameActive = false;
                this.gamePaused = false;
                this.waitForRestart = false;
                this.score = 0;
                this.lives = 7;
                this.level = 1;
                this.nextLevelScore = 25;
                this.invulnerable = false;
                this.invulnerableTimer = 0;
                this.characterLevel = 1; // Player character level (for upgrades)
                this.maxCharacterLevel = 6; // Max level for the character
                this.playerName = "";
                this.inIntro = true; // Add this line
                this.introVideoStarted = false; // Flag to prevent multiple video start attempts

                // Multiplayer Variables
                this.isMultiplayerMode = false;
                this.roomId = null; // generated room id
                this.clientPlayer = null; // client player info
                this.otherPlayers = {}; // Other player info
                this.multiplayerScores = []; // For multiplayer leaderboard

                // Player properties
                this.playerSize = 80;
                this.playerPos = { x: 160, y: 450 };
                this.playerSpeed = 5;
                this.bullets = [];
                this.bulletSpeed = 9;
                this.laserActive = false;
                this.laserTimer = 0;

                // Enemy properties
                this.enemies = [];
                this.enemySize = 50;
                this.enemySpeed = 1.2;
                this.spawnRate = 0.012;
                this.maxEnemies = 4;
                this.enemyFireRate = 0.006;
                this.enemyBullets = [];
                this.enemyBulletSpeed = 2.7;
                this.enemyBulletSize = 8;

                // Leaderboard data
                this.leaderboardData = this.loadLeaderboard();

                // Images
                this.loadImages();

                // Sounds
                this.loadSounds();

                // Input
                this.setupKeyboardControls();
                this.setupTouchControls();

                // Event listeners for intro screen click
                this.introScreen.addEventListener('mousedown', this.handleIntroClick.bind(this));
                this.introScreen.addEventListener('touchstart', this.handleIntroClick.bind(this));

                this.showLeaderboardButton.addEventListener('click', this.toggleLeaderboard.bind(this));
                this.showMultiplayerButton.addEventListener('click', this.showMultiplayerPanel.bind(this));
                this.createRoomBtn.addEventListener('click', this.createRoom.bind(this));
                this.joinRoomBtn.addEventListener('click', this.joinRoom.bind(this));
                this.closePanelBtn.addEventListener('click', this.closeMultiplayerPanel.bind(this));
                this.addBasePlayer(this.playerName);

                // Join room button click handler
                this.joinRoomBtn.addEventListener('click', () => {
                    this.roomIdInput.style.display = 'block';
                });

                console.log("Event listeners attached.");
                // Start the game loop
                this.lastTime = 0;
                this.init(); // call it first since init needs enemy array to be initialized
            }

            // Create client player for multiplayering
            addBasePlayer(name) {
                this.clientPlayer = {
                    "name": name,
                    "width": 80,
                    "height": 80,
                    "pos": { x: 160, y: 450 },
                    "score": 0
                }
            }

            /* Multiplayer Methods ************************************************************************************* */
            showMultiplayerPanel() {
                this.gamePaused = true;
                this.multiplayerPanel.style.display = 'block';
                
                // Clear previous player list
                const playerListDiv = document.getElementById('player-list');
                while (playerListDiv.children.length > 1) { // Keep the header
                    playerListDiv.removeChild(playerListDiv.lastChild);
                }
            }

            closeMultiplayerPanel() {
                this.gamePaused = false;
                this.multiplayerPanel.style.display = 'none';
            }

            createRoom() {
                this.playerName = this.playerNameInput.value.trim();
                if (!this.playerName) {
                    alert("Please enter your name.");
                    return;
                }

                this.roomId = this.generateRoomId();
                this.isMultiplayerMode = true; // Set mode here
                
                // Update client player with name
                this.clientPlayer.name = this.playerName;
                
                // Add self to player list
                this.updatePlayerList();
                
                // Show room creation success
                alert(`Room created! Room ID: ${this.roomId}. Share this with your friends.`);
                
                // Show start game button for room creator
                document.getElementById('start-game-btn').style.display = 'block';
                document.getElementById('start-game-btn').addEventListener('click', this.startMultiplayerGame.bind(this));
                
                this.multiplayerPanel.style.display = 'none';
                this.gamePaused = false;
            }

            joinRoom() {
                this.playerName = this.playerNameInput.value.trim();
                if (!this.playerName) {
                    alert("Please enter your name.");
                    return;
                }

                const roomId = this.roomIdInput.value.trim();
                if (!roomId) {
                    alert("Please enter the Room ID you wish to join");
                    this.roomIdInput.style.display = 'block';
                    return;
                }

                this.roomId = roomId;
                this.isMultiplayerMode = true; // Set mode here
                
                // Update client player with name
                this.clientPlayer.name = this.playerName;
                
                // Add self to player list
                this.updatePlayerList();
                
                // In a real implementation, we would verify the room exists
                alert(`Joining Room! Room ID: ${this.roomId}.`);
                
                this.multiplayerPanel.style.display = 'none';
                this.gamePaused = false;
            }

            startMultiplayerGame() {
                // In a real implementation, this would notify all players
                alert("Starting multiplayer game with all connected players!");
                this.closeMultiplayerPanel();
                this.init();
                this.gameActive = true;
                this.lastTime = performance.now();
                
                if (this.bgMusic) {
                    this.bgMusic.currentTime = 0;
                    this.bgMusic.play().catch(e => console.log("æ’­æ”¾éŸ³æ•ˆå¤±è´¥:", e));
                }
                
                requestAnimationFrame(this.gameLoop.bind(this));
            }

            updatePlayerList() {
                const playerListDiv = document.getElementById('player-list');
                
                // Clear previous list except header
                while (playerListDiv.children.length > 1) {
                    playerListDiv.removeChild(playerListDiv.lastChild);
                }
                
                // Add self
                const selfDiv = document.createElement('div');
                selfDiv.textContent = `${this.playerName} (You)`;
                playerListDiv.appendChild(selfDiv);
                
                // Add other players (simulated for now)
                // In a real implementation, this would come from server data
                const simulatedPlayers = [
                    { name: "Player 2", score: 120 },
                    { name: "Player 3", score: 85 }
                ];
                
                simulatedPlayers.forEach(player => {
                    const playerDiv = document.createElement('div');
                    playerDiv.textContent = `${player.name}`;
                    playerListDiv.appendChild(playerDiv);
                    
                    // Store in otherPlayers for rendering
                    this.otherPlayers[player.name] = {
                        name: player.name,
                        score: player.score,
                        pos: { 
                            x: Math.random() * (this.canvas.width - this.playerSize),
                            y: Math.random() * (this.canvas.height/2) + 100
                        },
                        width: this.playerSize,
                        height: this.playerSize
                    };
                });
                
                // Update multiplayer scores for leaderboard
                this.updateMultiplayerScores();
            }

            updateMultiplayerScores() {
                this.multiplayerScores = [
                    { name: this.playerName, score: this.score }
                ];
                
                // Add other players' scores
                Object.values(this.otherPlayers).forEach(player => {
                    this.multiplayerScores.push({
                        name: player.name,
                        score: player.score
                    });
                });
                
                // Sort by score (highest first)
                this.multiplayerScores.sort((a, b) => b.score - a.score);
            }

            generateRoomId() {
                return Math.random().toString(36).substring(2, 10).toUpperCase(); // Generate more unique ID
            }

            /* Enemy Methods ************************************************************************************* */

            // æ•Œäººå‘å°„æ•£å¼¹
            fireEnemyShotgun(enemy) {
                // å‘å°„ä¸‰ä¸ªæ–¹å‘çš„å­å¼¹
                for (let i = -1; i <= 1; i++) {
                    const angle = (i * 15) * Math.PI / 180; // Spread angle

                    this.enemyBullets.push({
                        x: enemy.x + this.enemySize / 2,
                        y: enemy.y + this.enemySize,
                        angle: angle // Bullet Angle
                    });
                }
            }

            /* Game Draw Methods ************************************************************************************* */
            drawOtherPlayers() {
                if (!this.isMultiplayerMode) {
                    return;
                }
                
                // Draw other players
                Object.values(this.otherPlayers).forEach(player => {
                    // Draw player character
                    if (this.playerLoaded) {
                        this.ctx.drawImage(this.playerImage, player.pos.x, player.pos.y, player.width, player.height);
                    } else {
                        this.ctx.fillStyle = 'blue'; // Different color for other players
                        this.ctx.fillRect(player.pos.x, player.pos.y, player.width, player.height);
                    }
                    
                    // Draw player name above character
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = '12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(player.name, player.pos.x + player.width/2, player.pos.y - 5);
                    this.ctx.textAlign = 'left';
                });
            }

            drawPlayer() {
                if (!this.gameActive) return; // Don't draw if the game is not active

                if (this.playerLoaded) {
                    //  Flicker the player image if invulnerable
                    if (this.invulnerable && Math.floor(Date.now() / 100) % 2) { // Blink effect
                        return; // Skip drawing for flicker effect
                    }
                    this.ctx.drawImage(this.playerImage, this.playerPos.x, this.playerPos.y, this.playerSize, this.playerSize);
                    
                    // In multiplayer mode, draw player name above character
                    if (this.isMultiplayerMode) {
                        this.ctx.fillStyle = 'white';
                        this.ctx.font = '12px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText(this.playerName, this.playerPos.x + this.playerSize/2, this.playerPos.y - 5);
                        this.ctx.textAlign = 'left';
                    }
                } else {
                    this.ctx.fillStyle = 'green';
                    if (this.invulnerable && Math.floor(Date.now() / 100) % 2) { // Blink effect
                        return; // Skip drawing for flicker effect
                    }
                    this.ctx.fillRect(this.playerPos.x, this.playerPos.y, this.playerSize, this.playerSize);
                    
                    // In multiplayer mode, draw player name above character
                    if (this.isMultiplayerMode) {
                        this.ctx.fillStyle = 'white';
                        this.ctx.font = '12px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText(this.playerName, this.playerPos.x + this.playerSize/2, this.playerPos.y - 5);
                        this.ctx.textAlign = 'left';
                    }
                }
            }

            drawInfoPanel() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                this.ctx.fillRect(0, 0, 150, 130); // å¢åŠ é«˜åº¦ä»¥å®¹çº³è§’è‰²ç­‰çº§

                this.ctx.fillStyle = 'white';
                this.ctx.font = '12px Arial';
                this.ctx.fillText(`åˆ†æ•°: ${this.score}`, 10, 20);
                this.ctx.fillText(`ç”Ÿå‘½: ${this.lives}`, 10, 40);
                this.ctx.fillText(`æ¸¸æˆç­‰çº§: ${this.level}`, 10, 60);
                this.ctx.fillText(`è§’è‰²ç­‰çº§: ${this.characterLevel}`, 10, 80); // æ˜¾ç¤ºè§’è‰²ç­‰çº§

                this.ctx.fillStyle = this.invulnerable ? 'yellow' : 'white'; // Highlight when invulnerable
                this.ctx.fillText(`æ— æ•Œ: ${this.invulnerable ? this.invulnerableTimer.toFixed(1) : 'å¦'}`, 10, 100);

                // Display multiplayer room info if in multiplayer mode
                if (this.isMultiplayerMode) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    this.ctx.fillRect(this.canvas.width - 150, 0, 150, 30);
                    this.ctx.fillStyle = 'yellow';
                    this.ctx.font = '12px Arial';
                    this.ctx.fillText(`å¤šäººæˆ¿é—´: ${this.roomId}`, this.canvas.width - 140, 20);
                }

                this.ctx.font = '8px Arial';
            }

            drawExplosion(x, y, size) {
                const colors = [
                    'rgba(255, 179, 51, 1)',
                    'rgba(255, 128, 26, 1)',
                    'rgba(255, 77, 26, 1)',
                    'rgba(230, 26, 26, 1)'
                ];

                for (let r = 1; r <= 4; r++) {
                    for (let j = 1; j <= 8; j++) { // ä¿®æ”¹å˜é‡åé¿å…å†²çª
                        const angle = j * Math.PI / 4;
                        const distance = size * r / 4;
                        const xp = x + Math.cos(angle) * distance * (0.7 + 0.3 * Math.random());
                        const yp = y + Math.sin(angle) * distance * (0.7 + 0.3 * Math.random());
                        const rad = size * (0.3 - r * 0.05) * (0.7 + 0.3 * Math.random());

                        this.ctx.fillStyle = colors[r - 1];
                        this.ctx.beginPath();
                        this.ctx.arc(xp, yp, rad, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
            }

            drawLaser() {
                // æ¿€å…‰ä»è§’è‰²ä¸­å¿ƒå‘ä¸Šå‘å°„ï¼Œè¦†ç›–æ•´ä¸ªç”»å¸ƒå®½åº¦
                this.ctx.fillStyle = 'rgba(255, 0, 0, 0.7)'; // çº¢è‰²æ¿€å…‰
                // æ¿€å…‰å®½åº¦å¯ä»¥æ ¹æ®éœ€è¦è°ƒæ•´ï¼Œè¿™é‡Œå‡è®¾ä¸º10px
                const laserWidth = 10;
                this.ctx.fillRect(this.playerPos.x + this.playerSize / 2 - laserWidth / 2, 0, laserWidth, this.playerPos.y);
            }

            /* Update Methods ************************************************************************************* */
            updateLaser(deltaTime) {
                if (this.laserActive) {
                    this.drawLaser();
                    this.laserTimer -= deltaTime / 1000;
                    if (this.laserTimer <= 0) {
                        this.laserActive = false;
                        this.laserTimer = 0;
                    }
                    this.laserCollisionDetection();
                }
            }

            updateOtherPlayers(deltaTime) {
                if (!this.isMultiplayerMode) {
                    return;
                }
                
                // Simulate other players' movement
                // In a real implementation, this would be updated from server data
                Object.values(this.otherPlayers).forEach(player => {
                    // Random movement for simulation
                    if (Math.random() < 0.05) {
                        player.pos.x += (Math.random() - 0.5) * 10;
                        player.pos.x = Math.max(0, Math.min(player.pos.x, this.canvas.width - player.width));
                    }
                    
                    // Simulate score increase
                    if (Math.random() < 0.01) {
                        player.score += 5;
                    }
                });
                
                // Update multiplayer scores periodically
                if (Math.random() < 0.01) {
                    this.updateMultiplayerScores();
                }
            }

            updateEnemies(deltaTime) {
                if (!this.gameActive) return; // Don't update enemies if the game isn't active

                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    const enemyRect = { x: enemy.x, y: enemy.y, width: this.enemySize, height: this.enemySize };
                    const playerRect = { x: this.playerPos.x, y: this.playerPos.y, width: this.playerSize, height: this.playerSize };

                    if (!this.invulnerable && this.checkCollision(playerRect, enemyRect)) {
                        this.drawExplosion(
                            this.playerPos.x + this.playerSize / 2,
                            this.playerPos.y + this.playerSize / 2,
                            this.playerSize / 2
                        );
                        this.explosionSound.currentTime = 0;                        this.explosionSound.currentTime = 0;
                        this.explosionSound.play().catch(e => console.log("æ’­æ”¾éŸ³æ•ˆå¤±è´¥:", e));
                        this.lives--;
                        this.enemies.splice(i, 1);

                        // Make player invulnerable for a short time
                        this.invulnerable = true;
                        this.invulnerableTimer = 2; // 2 seconds of invulnerability

                        if (this.lives <= 0) {
                            this.gameOver();
                        }
                        continue;
                    }

                    // Move enemy
                    enemy.y += this.enemySpeed * (1 + (this.level - 1) * 0.1) * deltaTime / 16;

                    // Check if enemy has gone off screen
                    if (enemy.y > this.canvas.height) {
                        this.enemies.splice(i, 1);
                        continue;
                    }

                    // Enemy firing logic
                    if (Math.random() < this.enemyFireRate * deltaTime / 16) {
                        if (this.level >= 3 && Math.random() < 0.3) { // 30% chance for shotgun at level 3+
                            this.fireEnemyShotgun(enemy);
                        } else {
                            this.enemyBullets.push({
                                x: enemy.x + this.enemySize / 2,
                                y: enemy.y + this.enemySize,
                                angle: 0 // Straight down
                            });
                        }
                    }

                    // Draw enemy
                    if (this.enemyLoaded) {
                        this.ctx.drawImage(this.enemyImage, enemy.x, enemy.y, this.enemySize, this.enemySize);
                    } else {
                        this.ctx.fillStyle = 'red';
                        this.ctx.fillRect(enemy.x, enemy.y, this.enemySize, this.enemySize);
                    }
                }

                // Spawn new enemies
                if (this.enemies.length < this.maxEnemies && Math.random() < this.spawnRate * deltaTime / 16) {
                    this.enemies.push({
                        x: Math.random() * (this.canvas.width - this.enemySize),
                        y: -this.enemySize
                    });
                }
            }

            updateBullets(deltaTime) {
                if (!this.gameActive) return; // Don't update bullets if the game isn't active

                // Update player bullets
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    bullet.y -= this.bulletSpeed * deltaTime / 16;

                    // Remove bullet if it goes off screen
                    if (bullet.y < 0) {
                        this.bullets.splice(i, 1);
                        continue;
                    }

                    // Check for collisions with enemies
                    const bulletRect = { x: bullet.x - 2, y: bullet.y - 2, width: 4, height: 4 };
                    let hitEnemy = false;

                    for (let j = this.enemies.length - 1; j >= 0; j--) {
                        const enemy = this.enemies[j];
                        const enemyRect = { x: enemy.x, y: enemy.y, width: this.enemySize, height: this.enemySize };

                        if (this.checkCollision(bulletRect, enemyRect)) {
                            // Enemy hit
                            this.drawExplosion(enemy.x + this.enemySize / 2, enemy.y + this.enemySize / 2, this.enemySize / 2);
                            this.explosionSound.currentTime = 0;
                            this.explosionSound.play().catch(e => console.log("æ’­æ”¾éŸ³æ•ˆå¤±è´¥:", e));
                            this.enemies.splice(j, 1);
                            hitEnemy = true;
                            this.score += 5;

                            // Check for level up
                            if (this.score >= this.nextLevelScore) {
                                this.levelUp();
                            }

                            // Check for character upgrade
                            if (this.characterLevel < this.maxCharacterLevel && this.score >= this.characterLevel * 50) {
                                this.upgradeCharacter();
                            }

                            break;
                        }
                    }

                    if (hitEnemy) {
                        this.bullets.splice(i, 1);
                        continue;
                    }

                    // Draw bullet
                    this.ctx.fillStyle = 'yellow';
                    this.ctx.beginPath();
                    this.ctx.arc(bullet.x, bullet.y, 2, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // Update enemy bullets
                for (let i = this.enemyBullets.length - 1; i >= 0; i--) {
                    const bullet = this.enemyBullets[i];
                    // Apply angle to movement
                    bullet.x += Math.sin(bullet.angle) * this.enemyBulletSpeed * deltaTime / 16;
                    bullet.y += Math.cos(bullet.angle) * this.enemyBulletSpeed * deltaTime / 16;

                    // Remove bullet if it goes off screen
                    if (bullet.y > this.canvas.height || bullet.x < 0 || bullet.x > this.canvas.width) {
                        this.enemyBullets.splice(i, 1);
                        continue;
                    }

                    // Check for collision with player
                    const bulletRect = {
                        x: bullet.x - this.enemyBulletSize / 2,
                        y: bullet.y - this.enemyBulletSize / 2,
                        width: this.enemyBulletSize,
                        height: this.enemyBulletSize
                    };
                    const playerRect = {
                        x: this.playerPos.x,
                        y: this.playerPos.y,
                        width: this.playerSize,
                        height: this.playerSize
                    };

                    if (!this.invulnerable && this.checkCollision(bulletRect, playerRect)) {
                        // Player hit
                        this.drawExplosion(
                            this.playerPos.x + this.playerSize / 2,
                            this.playerPos.y + this.playerSize / 2,
                            this.playerSize / 4
                        );
                        this.explosionSound.currentTime = 0;
                        this.explosionSound.play().catch(e => console.log("æ’­æ”¾éŸ³æ•ˆå¤±è´¥:", e));
                        this.enemyBullets.splice(i, 1);
                        this.lives--;

                        // Make player invulnerable for a short time
                        this.invulnerable = true;
                        this.invulnerableTimer = 2; // 2 seconds of invulnerability

                        if (this.lives <= 0) {
                            this.gameOver();
                        }
                        continue;
                    }

                    // Draw enemy bullet
                    this.ctx.fillStyle = 'red';
                    this.ctx.beginPath();
                    this.ctx.arc(bullet.x, bullet.y, this.enemyBulletSize / 2, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }

            updateInvulnerability(deltaTime) {
                if (this.invulnerable) {
                    this.invulnerableTimer -= deltaTime / 1000;
                    if (this.invulnerableTimer <= 0) {
                        this.invulnerable = false;
                        this.invulnerableTimer = 0;
                    }
                }
            }

            laserCollisionDetection() {
                // æ£€æŸ¥æ¿€å…‰ä¸æ•Œäººçš„ç¢°æ’
                const laserX = this.playerPos.x + this.playerSize / 2;
                const laserWidth = 10; // ä¸ç»˜åˆ¶æ¿€å…‰æ—¶çš„å®½åº¦ä¸€è‡´

                // æ£€æŸ¥æ¯ä¸ªæ•Œäºº
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    // æ£€æŸ¥æ•Œäººæ˜¯å¦åœ¨æ¿€å…‰è·¯å¾„ä¸Š
                    if (enemy.x < laserX + laserWidth / 2 && 
                        enemy.x + this.enemySize > laserX - laserWidth / 2) {
                        // æ•Œäººåœ¨æ¿€å…‰è·¯å¾„ä¸Šï¼Œæ‘§æ¯å®ƒ
                        this.drawExplosion(enemy.x + this.enemySize / 2, enemy.y + this.enemySize / 2, this.enemySize / 2);
                        this.explosionSound.currentTime = 0;
                        this.explosionSound.play().catch(e => console.log("æ’­æ”¾éŸ³æ•ˆå¤±è´¥:", e));
                        this.enemies.splice(i, 1);
                        this.score += 5;

                        // æ£€æŸ¥å‡çº§
                        if (this.score >= this.nextLevelScore) {
                            this.levelUp();
                        }

                        // æ£€æŸ¥è§’è‰²å‡çº§
                        if (this.characterLevel < this.maxCharacterLevel && this.score >= this.characterLevel * 50) {
                            this.upgradeCharacter();
                        }
                    }
                }
            }

            /* Game State Methods ************************************************************************************* */
            init() {
                this.gameActive = false;
                this.gamePaused = false;
                this.waitForRestart = false;
                this.score = 0;
                this.lives = 7;
                this.level = 1;
                this.nextLevelScore = 25;
                this.invulnerable = false;
                this.invulnerableTimer = 0;
                this.characterLevel = 1;
                this.playerPos = { x: 160, y: 450 };
                this.enemies = [];
                this.bullets = [];
                this.enemyBullets = [];
                this.laserActive = false;
                this.laserTimer = 0;

                // Reset enemy properties
                this.enemySpeed = 1.2;
                this.spawnRate = 0.012;
                this.maxEnemies = 4;
                this.enemyFireRate = 0.006;

                // Hide game over screen
                this.gameOverScreen.style.display = 'none';

                // Update leaderboard display
                if (this.isMultiplayerMode) {
                    this.updateMultiplayerScores();
                }
            }

            levelUp() {
                this.level++;
                this.nextLevelScore = this.nextLevelScore * 2;
                this.maxEnemies = Math.min(10, this.maxEnemies + 1);
                this.spawnRate = Math.min(0.03, this.spawnRate * 1.2);
                this.enemyFireRate = Math.min(0.015, this.enemyFireRate * 1.2);

                // Activate laser on certain levels
                if (this.level % 3 === 0) {
                    this.activateLaser();
                }
            }

            upgradeCharacter() {
                this.characterLevel++;
                
                // Update player image based on level
                if (this.characterLevel <= this.maxCharacterLevel) {
                    this.loadPlayerImage();
                }
            }

            activateLaser() {
                this.laserActive = true;
                this.laserTimer = 3; // æ¿€å…‰æŒç»­3ç§’
                
                // æ’­æ”¾æ¿€å…‰éŸ³æ•ˆ
                if (this.laserSound) {
                    this.laserSound.currentTime = 0;
                    this.laserSound.play().catch(e => console.log("æ’­æ”¾æ¿€å…‰éŸ³æ•ˆå¤±è´¥:", e));
                }
            }

            gameOver() {
                this.gameActive = false;
                this.waitForRestart = true;
                this.finalScoreText.textContent = `æœ€ç»ˆåˆ†æ•°: ${this.score}`;
                this.gameOverScreen.style.display = 'block';

                // Save to leaderboard if not in multiplayer mode
                if (!this.isMultiplayerMode) {
                    this.saveToLeaderboard();
                }

                // Stop background music
                if (this.bgMusic) {
                    this.bgMusic.pause();
                }
            }

            restart() {
                if (!this.waitForRestart) return;

                this.init();
                this.gameActive = true;
                this.lastTime = performance.now();
                this.waitForRestart = false;

                // Start background music
                if (this.bgMusic) {
                    this.bgMusic.currentTime = 0;
                    this.bgMusic.play().catch(e => console.log("æ’­æ”¾éŸ³æ•ˆå¤±è´¥:", e));
                }

                requestAnimationFrame(this.gameLoop.bind(this));
            }

            togglePause() {
                this.gamePaused = !this.gamePaused;
                if (!this.gamePaused) {
                    this.lastTime = performance.now();
                    requestAnimationFrame(this.gameLoop.bind(this));
                }
            }

            /* Leaderboard Methods ************************************************************************************* */
            loadLeaderboard() {
                const leaderboardData = localStorage.getItem('pokemonSpaceLeaderboard');
                return leaderboardData ? JSON.parse(leaderboardData) : [];
            }

            saveToLeaderboard() {
                // å¦‚æœæ²¡æœ‰ç©å®¶åç§°ï¼Œæç¤ºè¾“å…¥
                if (!this.playerName) {
                    const name = prompt("è¯·è¾“å…¥ä½ çš„åå­—ä»¥ä¿å­˜åˆ†æ•°:", "");
                    if (name) {
                        this.playerName = name;
                    } else {
                        return; // ç”¨æˆ·å–æ¶ˆäº†è¾“å…¥
                    }
                }

                // åˆ›å»ºæ–°çš„è®°å½•
                const newEntry = {
                    name: this.playerName,
                    score: this.score,
                    date: new Date().toISOString()
                };

                // æ·»åŠ åˆ°æ’è¡Œæ¦œ
                this.leaderboardData.push(newEntry);

                // æŒ‰åˆ†æ•°æ’åº
                this.leaderboardData.sort((a, b) => b.score - a.score);

                // åªä¿ç•™å‰10å
                if (this.leaderboardData.length > 10) {
                    this.leaderboardData = this.leaderboardData.slice(0, 10);
                }

                // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
                localStorage.setItem('pokemonSpaceLeaderboard', JSON.stringify(this.leaderboardData));
            }

            toggleLeaderboard() {
                this.leaderboardElement.style.display =
                    this.leaderboardElement.style.display === 'none' ? 'block' : 'none';
                
                if (this.leaderboardElement.style.display === 'block') {
                    if (this.isMultiplayerMode) {
                        this.updateMultiplayerLeaderboardDisplay();
                    } else {
                        this.updateLeaderboardDisplay();
                    }
                }
            }

            updateLeaderboardDisplay() {
                this.leaderboardList.innerHTML = ''; // Clear old list
                
                // Update header to show it's single player
                const leaderboardHeader = this.leaderboardElement.querySelector('h2');
                leaderboardHeader.textContent = 'å•äººæ¸¸æˆæ’è¡Œæ¦œ';
                
                if (this.leaderboardData.length === 0) {
                    const li = document.createElement('li');
                    li.textContent = 'æš‚æ— è®°å½•';
                    this.leaderboardList.appendChild(li);
                } else {
                    this.leaderboardData.forEach((entry, index) => {
                        const li = document.createElement('li');
                        li.textContent = `ç¬¬ ${index + 1} å: ${entry.name} - ${entry.score} åˆ†`;
                        this.leaderboardList.appendChild(li);
                    });
                }
            }

            updateMultiplayerLeaderboardDisplay() {
                this.leaderboardList.innerHTML = ''; // Clear old list
                
                // Update header to show it's multiplayer
                const leaderboardHeader = this.leaderboardElement.querySelector('h2');
                leaderboardHeader.textContent = 'å¤šäººæ¸¸æˆæ’è¡Œæ¦œ';
                
                if (this.multiplayerScores.length === 0) {
                    const li = document.createElement('li');
                    li.textContent = 'æš‚æ— è®°å½•';
                    this.leaderboardList.appendChild(li);
                } else {
                    this.multiplayerScores.forEach((entry, index) => {
                        const li = document.createElement('li');
                        li.textContent = `ç¬¬ ${index + 1} å: ${entry.name} - ${entry.score} åˆ†`;
                        
                        // Highlight current player
                        if (entry.name === this.playerName) {
                            li.style.color = '#ffff00'; // Yellow highlight
                            li.style.fontWeight = 'bold';
                        }
                        
                        this.leaderboardList.appendChild(li);
                    });
                }
            }

            /* Input Methods ************************************************************************************* */
            setupKeyboardControls() {
                document.addEventListener('keydown', (e) => {
                    if (this.waitForRestart) {
                        this.restart();
                        return;
                    }

                    if (this.gamePaused) return;

                    switch (e.key) {
                        case 'ArrowLeft':
                        case 'a':
                        case 'A':
                            this.moveLeft = true;
                            break;
                        case 'ArrowRight':
                        case 'd':
                        case 'D':
                            this.moveRight = true;
                            break;
                        case 'ArrowUp':
                        case 'w':
                        case 'W':
                            this.moveUp = true;
                            break;
                        case 'ArrowDown':
                        case 's':
                        case 'S':
                            this.moveDown = true;
                            break;
                        case ' ':
                            this.fireBullet();
                            break;
                        case 'p':
                        case 'P':
                            this.togglePause();
                            break;
                        case 'l':
                        case 'L':
                            this.toggleLeaderboard();
                            break;
                    }
                });

                document.addEventListener('keyup', (e) => {
                    switch (e.key) {
                        case 'ArrowLeft':
                        case 'a':
                        case 'A':
                            this.moveLeft = false;
                            break;
                        case 'ArrowRight':
                        case 'd':
                        case 'D':
                            this.moveRight = false;
                            break;
                        case 'ArrowUp':
                        case 'w':
                        case 'W':
                            this.moveUp = false;
                            break;
                        case 'ArrowDown':
                        case 's':
                        case 'S':
                            this.moveDown = false;
                            break;
                    }
                });
            }

            setupTouchControls() {
                // Joystick controls
                const joystick = document.getElementById('joystick');
                const joystickHandle = document.getElementById('joystick-handle');
                const fireButton = document.getElementById('fire-button');
                const pauseButton = document.getElementById('pause-button');

                let joystickActive = false;
                let joystickPos = { x: 0, y: 0 };
                let joystickStartPos = { x: 0, y: 0 };

                // Joystick touch start
                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = joystick.getBoundingClientRect();
                    joystickStartPos = {
                        x: touch.clientX - rect.left,
                        y: touch.clientY - rect.top
                    };
                    joystickActive = true;
                });

                // Joystick touch move
                joystick.addEventListener('touchmove', (e) => {
                    if (!joystickActive) return;
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = joystick.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;

                    // Calculate distance from center
                    const dx = x - joystickStartPos.x;
                    const dy = y - joystickStartPos.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const maxDistance = 25; // Maximum joystick movement

                    if (distance > maxDistance) {
                        // Normalize to max distance
                        const angle = Math.atan2(dy, dx);
                        joystickPos = {
                            x: Math.cos(angle) * maxDistance,
                            y: Math.sin(angle) * maxDistance
                        };
                    } else {
                        joystickPos = { x: dx, y: dy };
                    }

                    // Update joystick handle position
                    joystickHandle.style.transform = `translate(${joystickPos.x}px, ${joystickPos.y}px)`;

                    // Set movement flags based on joystick position
                    this.moveLeft = joystickPos.x < -10;
                    this.moveRight = joystickPos.x > 10;
                    this.moveUp = joystickPos.y < -10;
                    this.moveDown = joystickPos.y > 10;
                });

                // Joystick touch end
                joystick.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    joystickActive = false;
                    joystickPos = { x: 0, y: 0 };
                    joystickHandle.style.transform = 'translate(0px, 0px)';
                    this.moveLeft = false;
                    this.moveRight = false;
                    this.moveUp = false;
                    this.moveDown = false;
                });

                // Fire button
                fireButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.fireBullet();
                });

                // Pause button
                pauseButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    this.togglePause();
                });

                // Game over screen touch to restart
                this.gameOverScreen.addEventListener('touchstart', (e) => {
                    if (this.waitForRestart) {
                        e.preventDefault();
                        this.restart();
                    }
                });
            }

            handleIntroClick(e) {
                e.preventDefault();
                console.log("Intro screen clicked");

                // Hide intro screen
                this.introScreen.style.display = 'none';
                this.inIntro = false;

                // Show game canvas and controls
                this.canvas.style.display = 'block';
                document.getElementById('joystick').style.display = 'flex';
                document.getElementById('fire-button').style.display = 'flex';
                document.getElementById('pause-button').style.display = 'flex';
                document.getElementById('show-leaderboard-button').style.display = 'flex';
                document.getElementById('show-multiplayer-button').style.display = 'flex';

                // Start the game
                this.gameActive = true;
                this.lastTime = performance.now();
                requestAnimationFrame(this.gameLoop.bind(this));

                // Start background music
                if (this.bgMusic) {
                    this.bgMusic.play().catch(e => console.log("æ’­æ”¾èƒŒæ™¯éŸ³ä¹å¤±è´¥:", e));
                }
            }

            fireBullet() {
                if (!this.gameActive || this.gamePaused) return;

                // Create bullet at player position
                this.bullets.push({
                    x: this.playerPos.x + this.playerSize / 2,
                    y: this.playerPos.y
                });

                // Play shoot sound
                if (this.shootSound) {
                    this.shootSound.currentTime = 0;
                    this.shootSound.play().catch(e => console.log("æ’­æ”¾éŸ³æ•ˆå¤±è´¥:", e));
                }

                // Fire multiple bullets if character level is high enough
                if (this.characterLevel >= 3) {
                    // Add second bullet slightly to the left
                    this.bullets.push({
                        x: this.playerPos.x + this.playerSize / 4,
                        y: this.playerPos.y
                    });
                }

                if (this.characterLevel >= 5) {
                    // Add third bullet slightly to the right
                    this.bullets.push({
                        x: this.playerPos.x + this.playerSize * 3 / 4,
                        y: this.playerPos.y
                    });
                }
            }

            /* Helper Methods ************************************************************************************* */
            checkCollision(rect1, rect2) {
                return (
                    rect1.x < rect2.x + rect2.width &&
                    rect1.x + rect1.width > rect2.x &&
                    rect1.y < rect2.y + rect2.height &&
                    rect1.y + rect1.height > rect2.y
                );
            }

            loadImages() {
                // Load player image
                this.playerLoaded = false;
                this.loadPlayerImage();

                // Load enemy image
                this.enemyLoaded = false;
                this.enemyImage = new Image();
                this.enemyImage.src = 'images/enemy.png'; // Replace with your enemy image path
                this.enemyImage.onload = () => {
                    this.enemyLoaded = true;
                };

                // Load background image
                this.bgLoaded = false;
                this.bgImage = new Image();
                this.bgImage.src = 'images/space_bg.jpg'; // Replace with your background image path
                this.bgImage.onload = () => {
                    this.bgLoaded = true;
                };
            }

            loadPlayerImage() {
                this.playerImage = new Image();
                // Use different images based on character level
                this.playerImage.src = `images/player_level_${this.characterLevel}.png`; // Replace with your player image path
                this.playerImage.onload = () => {
                    this.playerLoaded = true;
                };
            }

            loadSounds() {
                // Load shoot sound
                this.shootSound = new Audio('sounds/shoot.wav'); // Replace with your shoot sound path
                this.shootSound.volume = 0.3;

                // Load explosion sound
                this.explosionSound = new Audio('sounds/explosion.wav'); // Replace with your explosion sound path
                this.explosionSound.volume = 0.5;

                // Load background music
                this.bgMusic = new Audio('sounds/background.mp3'); // Replace with your background music path
                this.bgMusic.volume = 0.2;
                this.bgMusic.loop = true;

                // Load laser sound
                this.laserSound = new Audio('sounds/laser.wav'); // Replace with your laser sound path
                this.laserSound.volume = 0.4;
            }

            /* Game Loop ************************************************************************************* */
            gameLoop(timestamp) {
                if (this.gamePaused) return;

                // Calculate delta time
                const deltaTime = timestamp - this.lastTime;
                this.lastTime = timestamp;

                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw background
                if (this.bgLoaded) {
                    this.ctx.drawImage(this.bgImage, 0, 0, this.canvas.width, this.canvas.height);
                } else {
                    this.ctx.fillStyle = 'black';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                }

                if (this.gameActive) {
                    // Update player position
                    if (this.moveLeft) {
                        this.playerPos.x = Math.max(0, this.playerPos.x - this.playerSpeed * deltaTime / 16);
                    }
                    if (this.moveRight) {
                        this.playerPos.x = Math.min(this.canvas.width - this.playerSize, this.playerPos.x + this.playerSpeed * deltaTime / 16);
                    }
                    if (this.moveUp) {
                        this.playerPos.y = Math.max(0, this.playerPos.y - this.playerSpeed * deltaTime / 16);
                    }
                    if (this.moveDown) {
                        this.playerPos.y = Math.min(this.canvas.height - this.playerSize, this.playerPos.y + this.playerSpeed * deltaTime / 16);
                    }

                    // Update game elements
                    this.updateEnemies(deltaTime);
                    this.updateBullets(deltaTime);
                    this.updateInvulnerability(deltaTime);
                    this.updateLaser(deltaTime);
                    
                    // Update other players in multiplayer mode
                    if (this.isMultiplayerMode) {
                        this.updateOtherPlayers(deltaTime);
                        this.drawOtherPlayers();
                    }

                    // Draw player
                    this.drawPlayer();

                    // Draw info panel
                    this.drawInfoPanel();
                }

                // Request next frame
                if (this.gameActive) {
                    requestAnimationFrame(this.gameLoop.bind(this));
                }
            }
        }

        // Start the game when the page loads
        window.onload = () => {
            console.log("Window loaded, starting game");
            const game = new PokemonSpaceGame();
        };
    </script>
</body>

</html>
