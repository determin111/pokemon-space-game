<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å®å¯æ¢¦å¤ªç©ºå¯¹æˆ˜</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            position: fixed;
            overflow: hidden;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        #gameCanvas {
            border: 1px solid #333;
            max-width: 100%;
            max-height: 100%;
        }
        .game-over {
            position: absolute;
            color: white;
            text-align: center;
            display: none;
        }
        .game-over h1 {
            color: red;
            font-size: 30px;
        }
        .game-over p {
            font-size: 20px;
            margin: 10px 0;
        }

        #joystick {
            position: absolute;
            bottom: 30px; /* è°ƒæ•´æ‘‡æ†çš„ä½ç½® */
            left: 30px;   /* è°ƒæ•´æ‘‡æ†çš„ä½ç½® */
            width: 100px;
            height: 100px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 50%;  /* ä½¿å®ƒå˜æˆåœ†å½¢ */
            display: flex;
            justify-content: center; /* æ°´å¹³å±…ä¸­ */
            align-items: center;    /* å‚ç›´å±…ä¸­ */
        }

        #joystick-handle {
            width: 50px;
            height: 50px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 50%;  /* ä½¿æ‰‹æŸ„å˜æˆåœ†å½¢ */
            position: absolute;
        }

         #fire-button {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 80px;
            height: 80px;
            background-color: rgba(255, 0, 0, 0.7);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            user-select: none; /* ç¦æ­¢æ–‡æœ¬é€‰æ‹© */
        }

        #pause-button {
        position: absolute;
        top: 30px;
        right: 30px;
        width: 60px;
        height: 40px;
        background-color: rgba(0, 0, 255, 0.7);
        border-radius: 5px;
        display: flex;
        justify-content: center;
        align-items: center;
        color: white;
        font-size: 18px;
        user-select: none; /* ç¦æ­¢æ–‡æœ¬é€‰æ‹© */
    }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="400" height="600"></canvas>
    <div class="game-over" id="gameOverScreen">
        <h1>æ¸¸æˆç»“æŸ</h1>
        <p id="finalScore">æœ€ç»ˆåˆ†æ•°: 0</p>
        <p>æŒ‰ä»»æ„é”®æˆ–ç‚¹å‡»å±å¹•é‡æ–°å¼€å§‹</p>
    </div>

    <!-- æ‘‡æ† -->
    <div id="joystick">
        <div id="joystick-handle"></div>
    </div>
     <!-- å°„å‡»æŒ‰é’® -->
    <div id="fire-button">ğŸ”¥</div>
     <!-- æš‚åœæŒ‰é’® -->
    <div id="pause-button">â¸ï¸</div>

    <script>
        // æ¸¸æˆä¸»ç±»
        class PokemonSpaceGame {
            constructor() {
                // è·å–ç”»å¸ƒå’Œä¸Šä¸‹æ–‡
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.gameOverScreen = document.getElementById('gameOverScreen');
                this.finalScoreText = document.getElementById('finalScore');

                // æ¸¸æˆçŠ¶æ€
                this.gameActive = true;
                this.gamePaused = false;
                this.waitForRestart = false;
                this.score = 0;
                this.lives = 7; // Adjusted starting lives
                this.level = 1;
                this.nextLevelScore = 25;  // Adjusted score needed to level up
                this.invulnerable = false; // Player invulnerability state
                this.invulnerableTimer = 0; // Timer for invulnerability


                // ç©å®¶ç›¸å…³å‚æ•°
                this.playerSize = 80;
                this.playerPos = {x: 160, y: 450};
                this.bullets = [];
                this.bulletSpeed = 9;  // Adjusted player bullet

                // æ•Œäººç›¸å…³å‚æ•° - Even further reduced difficulty
                this.enemies = [];
                this.enemySize = 50;
                this.enemySpeed = 1.2; // Adjusted enemy speed
                this.spawnRate = 0.012; // Adjusted spawn rate
                this.maxEnemies = 4;   // Adjusted max enemies
                this.enemyFireRate = 0.006; // Adjusted enemy fire rate
                this.enemyBullets = [];
                this.enemyBulletSpeed = 2.7; // Adjusted enemy bullet speed
                this.enemyBulletSize = 8;

                // åŠ è½½å›¾åƒ
                this.loadImages();

                // åŠ è½½éŸ³æ•ˆ
                this.loadSounds();

                // è®¾ç½®é”®ç›˜äº‹ä»¶ç›‘å¬
                this.setupKeyboardControls();

                // è®¾ç½®è§¦æ‘¸æ§åˆ¶
                this.setupTouchControls();

                 // æ·»åŠ ç‚¹å‡»å±å¹•é‡æ–°å¼€å§‹çš„äº‹ä»¶ç›‘å¬å™¨
                document.addEventListener('mousedown', this.handleRestart.bind(this));  //é¼ æ ‡ç‚¹å‡»
                document.addEventListener('touchstart', this.handleRestart.bind(this)); //è§¦æ‘¸

                // å¼€å§‹æ¸¸æˆå¾ªç¯
                this.lastTime = 0;
                this.init();
                setInterval(() => {
                    if (this.gameActive && !this.gamePaused) {
                        this.updatePlayerPosition();
                    }
                }, 20); // æ¯ 20 æ¯«ç§’
            }

            loadImages() {
                // èƒŒæ™¯å›¾åƒ
                this.bgImage = new Image();
                this.bgImage.src = 'images/earth_view.jpg';
                this.bgImage.onload = () => this.bgLoaded = true;

                // ç©å®¶å›¾åƒ
                this.playerImage = new Image();
                this.playerImage.src = 'images/rayquaza.png';
                this.playerImage.onload = () => this.playerLoaded = true;

                // æ•Œäººå›¾åƒ
                this.enemyImage = new Image();
                this.enemyImage.src = 'images/deoxys.png';
                this.enemyImage.onload = () => this.enemyLoaded = true;
            }

            loadSounds() {
                // èƒŒæ™¯éŸ³ä¹
                this.bgMusic = new Audio('sounds/background_music.mp3');
                this.bgMusic.loop = true;

                // å°„å‡»éŸ³æ•ˆ
                this.playerShootSound = new Audio('sounds/player_shoot.mp3');
                this.enemyShootSound = new Audio('sounds/enemy_shoot.mp3');

                // çˆ†ç‚¸éŸ³æ•ˆ
                this.explosionSound = new Audio('sounds/explosion.mp3');

                // å‡çº§éŸ³æ•ˆ
                this.levelUpSound = new Audio('sounds/level_up.mp3');
            }

            setupKeyboardControls() {
                document.addEventListener('keydown', (e) => {
                    // å¤„ç†æ¸¸æˆç»“æŸåçš„é‡æ–°å¼€å§‹
                    if (this.waitForRestart) {
                        this.init();
                        return;
                    }

                    // å¤„ç†æ¸¸æˆæš‚åœçŠ¶æ€ä¸‹çš„æŒ‰é”®
                    if (this.gamePaused && e.key !== 'p') {
                        return;
                    }

                    switch (e.key) {
                        case 'ArrowLeft':
                            this.playerPos.x = Math.max(0, this.playerPos.x - 15);
                            break;
                        case 'ArrowRight':
                            this.playerPos.x = Math.min(400 - this.playerSize, this.playerPos.x + 15);
                            break;
                        case 'ArrowUp':
                            this.playerPos.y = Math.max(0, this.playerPos.y - 15);
                            break;
                        case 'ArrowDown':
                            this.playerPos.y = Math.min(600 - this.playerSize * 1.2, this.playerPos.y + 15);
                            break;
                        case ' ': // ç©ºæ ¼é”®
                            this.fireBullet();
                            break;
                        case 'p':
                            this.gamePaused = !this.gamePaused;

                            // å¤„ç†èƒŒæ™¯éŸ³ä¹
                            if (this.gamePaused) {
                                this.bgMusic.pause();
                            } else {
                                this.bgMusic.play().catch(e => console.log("æ’­æ”¾éŸ³æ•ˆå¤±è´¥:", e));
                            }
                            break;
                    }
                });
            }

            handleRestart(e) {
                if (this.waitForRestart) {
                    e.preventDefault(); // é˜»æ­¢é»˜è®¤è¡Œä¸º
                    this.init(); // é‡æ–°åˆå§‹åŒ–æ¸¸æˆ
                }
            }

            setupTouchControls() {
                const joystick = document.getElementById('joystick');
                const joystickHandle = document.getElementById('joystick-handle');
                const fireButton = document.getElementById('fire-button');
                const pauseButton = document.getElementById('pause-button');
                let joystickBaseX, joystickBaseY;
                let joystickTouchId = null;  // ç”¨äºè·Ÿè¸ªè§¦æ‘¸ID
                let playerDirectionX = 0, playerDirectionY = 0; // ç©å®¶ç§»åŠ¨æ–¹å‘

                // æ£€æŸ¥è§¦æ‘¸æ˜¯å¦åœ¨æŒ‡å®šèŒƒå›´å†…
                const isInZone = (x, y, zone) => {
                    return x >= zone.x && x <= zone.x + zone.width &&
                        y >= zone.y && y <= zone.y + zone.height;
                };

                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();

                    if (joystickTouchId === null && e.touches[0]) { // åªå¤„ç†ç¬¬ä¸€ä¸ªè§¦æ‘¸
                        joystickTouchId = e.touches[0].identifier;

                        joystickBaseX = e.touches[0].clientX - joystick.getBoundingClientRect().left;
                        joystickBaseY = e.touches[0].clientY - joystick.getBoundingClientRect().top;
                        // è°ƒæ•´æ‰‹æŸ„ä½ç½®
                        joystickHandle.style.left = `${joystickBaseX - 25}px`; // ä½¿æ‰‹æŸ„å±…ä¸­
                        joystickHandle.style.top = `${joystickBaseY - 25}px`; // ä½¿æ‰‹æŸ„å±…ä¸­
                    }
                }, { passive: false });

                joystick.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (joystickTouchId !== null) {
                        const touch = Array.from(e.touches).find(t => t.identifier === joystickTouchId);
                        if (touch) {
                            const touchX = touch.clientX - joystick.getBoundingClientRect().left;
                            const touchY = touch.clientY - joystick.getBoundingClientRect().top;
                            // è®¡ç®—è§¦æ‘¸ç‚¹è·æ‘‡æ†ä¸­å¿ƒç‚¹çš„åç§»
                            const deltaX = touchX - joystickBaseX;
                            const deltaY = touchY - joystickBaseY;

                            // è®¡ç®—è§¦æ‘¸ç‚¹è·ç¦»ä¸­å¿ƒç‚¹çš„è·ç¦»
                            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                            const maxDistance = joystick.offsetWidth / 2;                // è®¡ç®—æ–¹å‘ï¼Œå½’ä¸€åŒ–å‘é‡
                            playerDirectionX = deltaX / maxDistance;
                            playerDirectionY = deltaY / maxDistance;
                            // é™å®šæœ€å¤§è·ç¦»
                            if (distance > maxDistance) {
                                playerDirectionX = deltaX / distance;
                                playerDirectionY = deltaY / distance;
                            }

                            // æ›´æ–°æ‰‹æŸ„ä½ç½®
                            joystickHandle.style.left = `${joystickBaseX + playerDirectionX * maxDistance - 25}px`;
                            joystickHandle.style.top = `${joystickBaseY + playerDirectionY * maxDistance - 25}px`;
                        }
                    }
                }, { passive: false });

                joystick.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (e.changedTouches[0].identifier === joystickTouchId) {
                    joystickTouchId = null;
                        playerDirectionX = 0;
                        playerDirectionY = 0;

                        // å¤ä½æ‰‹æŸ„ä½ç½®
                        joystickHandle.style.left = `${50 - 25}px`;
                        joystickHandle.style.top = `${50 - 25}px`;
                    }
                }, { passive: false });

                joystick.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    console.log('cancel', e.touches)
                    joystickTouchId = null;
                    playerDirectionX = 0;
                    playerDirectionY = 0;
                    // å¤ä½æ‰‹æŸ„ä½ç½®
                    joystickHandle.style.left = `${50 - 25}px`;
                    joystickHandle.style.top = `${50 - 25}px`;
                }, { passive: false });

                // å°„å‡»æŒ‰é’®äº‹ä»¶
                fireButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.fireBullet();

                });

                // æš‚åœæŒ‰é’®äº‹ä»¶
                pauseButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.gamePaused = !this.gamePaused;

                    // å¤„ç†èƒŒæ™¯éŸ³ä¹
                    if (this.gamePaused) {
                        this.bgMusic.pause();
                    } else {
                        this.bgMusic.play().catch(e => console.log("æ’­æ”¾éŸ³æ•ˆå¤±è´¥:", e));
                    }
                });
                // æ›´æ–°ç©å®¶ç§»åŠ¨
                this.updatePlayerPosition = () => {
                    const speed = 5; // è°ƒæ•´é€Ÿåº¦
                    this.playerPos.x += playerDirectionX * speed;
                    this.playerPos.y += playerDirectionY * speed;
                    // è¾¹ç•Œæ£€æŸ¥
                    this.playerPos.x = Math.max(0, Math.min(this.playerPos.x, 400 - this.playerSize));
                    this.playerPos.y = Math.max(0, Math.min(this.playerPos.y, 600 - this.playerSize * 1.2));
                };
            }

            fireBullet() {
                // ä»megaè£‚ç©ºåº§çš„å£éƒ¨ä½ç½®å‘å°„é¾™æ¯å…‰çº¿
                this.bullets.push({
                    x: this.playerPos.x + this.playerSize / 2,
                    y: this.playerPos.y + this.playerSize / 4
                });

                // æ’­æ”¾å°„å‡»éŸ³æ•ˆ
                this.playerShootSound.currentTime = 0;
                this.playerShootSound.play().catch(e => console.log("æ’­æ”¾éŸ³æ•ˆå¤±è´¥:", e));
            }

            init() {
                 this.spawnRate = 0.012;
                // é‡ç½®æ¸¸æˆçŠ¶æ€
                this.gameActive = true;
                this.gamePaused = false;
                this.waitForRestart = false;
                this.playerPos = {x: 160, y: 450};
                this.bullets = [];
                this.enemies = [];
                this.enemyBullets = [];
                this.score = 0;
                this.lives = 7;
                this.level = 1;
                this.nextLevelScore = 25;
                this.enemySpeed = 1.2;
                this.enemyFireRate = 0.006;
                this.maxEnemies = 4;
                this.invulnerable = false;  // Reset invulnerability on game start
                this.invulnerableTimer = 0;

                // éšè—æ¸¸æˆç»“æŸå±å¹•
                this.gameOverScreen.style.display = 'none';

                // å¼€å§‹èƒŒæ™¯éŸ³ä¹
                this.bgMusic.play().catch(e => console.log("æ’­æ”¾éŸ³æ•ˆå¤±è´¥:", e));

                // å¼€å§‹æ¸¸æˆå¾ªç¯
                requestAnimationFrame(this.gameLoop.bind(this));
            }

            gameLoop(timestamp) {

                const deltaTime = timestamp - this.lastTime;
                this.lastTime = timestamp;

                if (this.gamePaused) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.font = '30px Arial';
                    this.ctx.fillStyle = 'white';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('æ¸¸æˆæš‚åœ', this.canvas.width / 2, this.canvas.height / 2);
                    this.ctx.textAlign = 'left';
                    requestAnimationFrame(this.gameLoop.bind(this));
                    return;
                }

                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                if (this.bgLoaded) {
                    this.ctx.drawImage(this.bgImage, 0, 0, 400, 600);
                } else {
                    this.ctx.fillStyle = 'black';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                }

                   // Generate new enemies (with the maximum limit check)
                   if (Math.random() < this.spawnRate && this.enemies.length < this.maxEnemies) {
                    const x = Math.random() * (400 - this.enemySize);
                    this.enemies.push({ x: x, y: 0 });
                   }

                this.drawPlayer();
                this.updateBullets();
                this.updateEnemies(deltaTime);
                this.updateEnemyBullets();
                this.drawInfoPanel();

                  if (this.score >= this.nextLevelScore) {
                    this.levelUp();
                    this.nextLevelScore = this.nextLevelScore * 2;
                  }

                    if (this.gameActive) {
                    requestAnimationFrame(this.gameLoop.bind(this));
                }
            }

             drawPlayer() {
                if (this.playerLoaded) {
                    //  Flicker the player image if invulnerable
                        if (this.invulnerable && Math.floor(Date.now() / 100) % 2) { // Blink effect
                            return; // Skip drawing for flicker effect
                        }
                   this.ctx.drawImage(this.playerImage, this.playerPos.x, this.playerPos.y, this.playerSize, this.playerSize);
                } else {
                    this.ctx.fillStyle = 'green';

                      if (this.invulnerable && Math.floor(Date.now() / 100) % 2) { // Blink effect
                         return; // Skip drawing for flicker effect
                    }
                    this.ctx.fillRect(this.playerPos.x, this.playerPos.y, this.playerSize, this.playerSize);
                }
            }

            updateBullets() {
                           for (let i = this.bullets.length - 1; i >= 0; i--) {
                    this.bullets[i].y -= this.bulletSpeed;
                    if (this.bullets[i].y < 0) {
                        this.bullets.splice(i, 1);
                        continue;
                    }

                    const x = this.bullets[i].x;
                    const y = this.bullets[i].y;
                    const rayLen = 40;

                    this.ctx.lineWidth = 5;
                    this.ctx.strokeStyle = 'rgba(0, 180, 255, 1)';
                    this.ctx.beginPath();
                    this.ctx.moveTo(x - 1, y);
                    this.ctx.lineTo(x + 1, y - rayLen);
                    this.ctx.stroke();

                    this.ctx.lineWidth = 8;
                    this.ctx.strokeStyle = 'rgba(0, 128, 255, 0.5)';
                    this.ctx.beginPath();
                    this.ctx.moveTo(x - 3, y);
                    this.ctx.lineTo(x + 3, y - rayLen * 0.8);
                    this.ctx.stroke();

                    this.ctx.fillStyle = 'rgba(0, 180, 255, 0.7)';
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 5, 0, Math.PI * 2);
                    this.ctx.fill();

                    for (let j = this.enemies.length - 1; j >= 0; j--) {
                        const enemy = this.enemies[j];
                        if (this.checkCollision(
                            { x: x - 5, y: y - rayLen }, 12,
                            { x: enemy.x, y: enemy.y }, this.enemySize
                        )) {
                            this.enemies.splice(j, 1);
                            this.score += 5;
                            this.drawExplosion(enemy.x + this.enemySize / 2, enemy.y + this.enemySize / 2, this.enemySize);
                            this.explosionSound.currentTime = 0;
                            this.explosionSound.play().catch(e => console.log("æ’­æ”¾éŸ³æ•ˆå¤±è´¥:", e));
                            this.bullets.splice(i, 1);
                            break;
                        }
                    }
                }
            }

            updateEnemies(deltaTime) {
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];

                   // Collision check only if player is NOT invulnerable for now
                 if (!this.invulnerable && this.checkCollision(
                    { x: this.playerPos.x, y: this.playerPos.y }, this.playerSize,
                    { x: enemy.x, y: enemy.y }, this.enemySize
                )) {
                       // Explosion on collision and player LOSES life:
                        this.drawExplosion(
                            this.playerPos.x + this.playerSize / 2,
                            this.playerPos.y + this.playerSize / 2,
                            this.playerSize / 2
                        );
                        this.explosionSound.currentTime = 0;
                        this.explosionSound.play().catch(e => console.log("æ’­æ”¾éŸ³æ•ˆå¤±è´¥:", e));

                       this.lives--; // Player loses a life on collision
                        this.enemies.splice(i, 1);   // Remove collided enemy

                        if (this.lives <= 0) {
                            this.gameOver();
                            return;
                       }

                        //Initiate invulnerability
                        this.invulnerable = true;
                        this.invulnerableTimer = 2;  // 2 seconds of invulnerability
                   } else {                  // No collisison, proceed with updating enemies locations :
                       this.enemies[i].y += this.enemySpeed;
                          if (this.enemies[i].y > 600 - this.enemySize) {
                             this.enemies.splice(i, 1);
                          }
                    }
                       //Check for enemy image validity:
                     if (this.enemyLoaded) {
                        this.ctx.drawImage(this.enemyImage, enemy.x, enemy.y, this.enemySize, this.enemySize);
                     } else {
                        this.ctx.fillStyle = 'red';
                        this.ctx.fillRect(enemy.x, enemy.y, this.enemySize, this.enemySize);
                     }

                // Fire randomly from enemies when no explosion detected
                   if (Math.random() < this.enemyFireRate) {
                        this.enemyBullets.push({
                            x: enemy.x + this.enemySize / 2,
                           y: enemy.y + this.enemySize / 2
                        });
                        this.enemyShootSound.currentTime = 0;
                         this.enemyShootSound.play().catch(e => console.log("æ’­æ”¾éŸ³æ•ˆå¤±è´¥:", e));
                    }
                }
              // Update invulnerability timer
              if (this.invulnerable) {
                    this.invulnerableTimer -= deltaTime / 1000;  // Assuming deltatime in ms
                   if (this.invulnerableTimer <= 0) {
                       this.invulnerable = false;   // Turn off invulnerability
                       this.invulnerableTimer = 0;  // Reset timer
                    }
                }
            }

            updateEnemyBullets() {
                for (let i = this.enemyBullets.length - 1; i >= 0; i--) {
                    // ç§»åŠ¨æ•Œäººå­å¼¹
                    this.enemyBullets[i].y += this.enemyBulletSpeed;

                    // æ£€æŸ¥å‡ºç•Œçš„æ•Œäººå­å¼¹
                    if (this.enemyBullets[i].y > 600) {
                        this.enemyBullets.splice(i, 1);
                        continue;
                    }

                    const bullet = this.enemyBullets[i];

                    // ç»˜åˆ¶è¶…èƒ½åŠ›çƒ
                    const ballSize = this.enemyBulletSize;

                    //çƒä½“å…‰æ™•æ•ˆæœ
                    this.ctx.fillStyle = 'rgba(255, 77, 255, 0.3)';
                    this.ctx.beginPath();
                    this.ctx.arc(bullet.x, bullet.y, ballSize * 1.5, 0, Math.PI * 2);
                    this.ctx.fill();

                    // ä¸»çƒä½“
                    this.ctx.fillStyle = 'rgba(255, 77, 255, 1)';
                    this.ctx.beginPath();
                    this.ctx.arc(bullet.x, bullet.y, ballSize, 0, Math.PI * 2);
                    this.ctx.fill();

                     // æ£€æŸ¥æ˜¯å¦å‡»ä¸­ç©å®¶  //Only collide when user is indeed not invulnerable
                      if (!this.invulnerable && this.checkCollision(
                        {x: this.playerPos.x, y: this.playerPos.y}, this.playerSize,
                        {x: bullet.x, y: bullet.y}, ballSize * 2
                    )) {
                        // çˆ†ç‚¸æ•ˆæœ
                        this.drawExplosion(
                            this.playerPos.x + this.playerSize/2,
                            this.playerPos.y + this.playerSize/2,
                            this.playerSize/2
                        );

                        // æ’­æ”¾çˆ†ç‚¸éŸ³æ•ˆ
                        this.explosionSound.currentTime = 0;
                        this.explosionSound.play().catch(e => console.log("playSoundFail:", e));

                        // å‡å°‘ç”Ÿå‘½å€¼
                        this.lives--;
                        if (this.lives <= 0) {
                            this.gameOver();
                            return;
                        }
                        //Initiate invulnerability
                         this.invulnerable = true;
                       this.invulnerableTimer = 2;  // 2 seconds of invulnerability

                      // åˆ é™¤å­å¼¹
                     this.enemyBullets.splice(i, 1);
                    }
                }
            }

            drawExplosion(x, y, size) {
                 const colors = [
                    'rgba(255, 179, 51, 1)',
                    'rgba(255, 128, 26, 1)',
                    'rgba(255, 77, 26, 1)',
                    'rgba(230, 26, 26, 1)'
                ];

                for (let r = 1; r <= 4; r++) {
                    for (let i = 1; i <= 8; i++) {
                        const angle = i * Math.PI / 4;
                        const distance = size * r / 4;
                        const xp = x + Math.cos(angle) * distance * (0.7 + 0.3 * Math.random());
                        const yp = y + Math.sin(angle) * distance * (0.7 + 0.3 * Math.random());
                        const rad = size * (0.3 - r * 0.05) * (0.7 + 0.3 * Math.random());

                        this.ctx.fillStyle = colors[r - 1];
                        this.ctx.beginPath();
                        this.ctx.arc(xp, yp, rad, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
            }

            drawInfoPanel() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                this.ctx.fillRect(0, 0, 150, 120);

                this.ctx.fillStyle = 'white';
                this.ctx.font = '12px Arial';
                this.ctx.fillText(`åˆ†æ•°: ${this.score}`, 10, 20);
                this.ctx.fillText(`ç”Ÿå‘½: ${this.lives}`, 10, 40);
                this.ctx.fillText(`ç­‰çº§: ${this.level}`, 10, 60);

                 this.ctx.fillStyle = this.invulnerable ? 'yellow' : 'white'; // Highlight when invulnerable
                this.ctx.fillText(`æ— æ•Œ: ${this.invulnerable ? this.invulnerableTimer.toFixed(1) : 'å¦'}`, 10, 75);

                this.ctx.font = '8px Arial';
                this.ctx.fillText('ç§»åŠ¨: æ‘‡æ†', 10, 85);
                this.ctx.fillText('å°„å‡»: ç«é”®', 10, 95);
                this.ctx.fillText('æš‚åœ: æš‚åœé”®', 10, 110);
            }

            levelUp() {
                    // æé«˜éš¾åº¦å’Œæ€ªç‰©èƒ½åŠ›åŒæ­¥é™ä½
                this.level++;
                this.enemySpeed *= 1.04;
                this.spawnRate = Math.min(this.spawnRate * 1.08, 0.07);
                this.enemyFireRate = Math.min(this.enemyFireRate * 1.08, 0.035);

                this.ctx.font = '24px Arial';
                this.ctx.fillStyle = 'yellow';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`å‡çº§åˆ° ${this.level} çº§!`, 200, 200);
                this.ctx.textAlign = 'left';

                this.levelUpSound.currentTime = 0;
                this.levelUpSound.play().catch(e => console.log("æ’­æ”¾éŸ³æ•ˆå¤±è´¥:", e));
            }

         gameOver() {
                this.bgMusic.pause();
                this.gameOverScreen.style.display = 'block';
                this.finalScoreText.textContent = `æœ€ç»ˆåˆ†æ•°: ${this.score}`;
                this.waitForRestart = true;
                this.gameActive = false;
            }

            checkCollision(pos1, sz1, pos2, sz2) {
                return !(
                    pos1.x + sz1 < pos2.x ||
                    pos2.x + sz2 < pos1.x ||
                    pos1.y + sz1 < pos2.y ||
                    pos2.y + sz2 < pos1.y
                );
            }
        }

        // å½“é¡µé¢åŠ è½½å®Œæˆåå¯åŠ¨æ¸¸æˆ
        window.onload = function() {
            new PokemonSpaceGame();
        };
    </script>
</body>
</html>
